// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Nulladmin.com aitokenizer
 *
 * Aitokenizer is a Nulladmin.com microservice which performs input tokenization for AI workloads. It supports various encodings used by OpenAI, Anthropic and others.
 *
 * API version: 1.0.0
 */

package main

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"go.uber.org/zap"

	flag "github.com/spf13/pflag"
	"github.com/spf13/viper"
	_ "github.com/spf13/viper/remote"

	aitokenizer "github.com/nulladmin/aitokenizer/go"
)

var (
	// Command line flag variables
	aConfigFile *string
	aDebug      *bool
	aVersion    *bool
	aHelp       *bool
)

func init() {

	// Setup the command line flags and viper bindings

	aConfigFile = flag.StringP("config", "c", "", "Path to configuration file")

	aVersion = flag.BoolP("version", "v", false, "Print version")
	aHelp = flag.BoolP("help", "h", false, "Print help")

	aDebug = flag.BoolP("debug", "d", false, "Enable debug level loging and tracing")
	viper.BindPFlag("debug", flag.Lookup("debug"))

}

func main() {

	flag.Usage = func() {
		fmt.Fprint(os.Stdout, fmt.Sprintf(aitokenizer.Usage))
	}
	flag.Parse()

	if *aHelp {
		flag.Usage()
		os.Exit(0)
	}
	if *aVersion {
		showVersion()
		os.Exit(0)
	}

	// Load the configuration from defaults or from a config file
	// loadConfig exits the program if there are problems with configuration
	loadConfig()

	// Initialize logging
	lz := aitokenizer.InitLogzap()
	defer lz.Sync()

	// We make the Zap logger global for ease of use in autogenerated OpenAPI code
	undo := zap.ReplaceGlobals(lz)
	defer undo()

	zap.L().Info("Starting aitokenizer")
	if *aConfigFile != "" {
		zap.L().Info("Read config file", zap.String("config", *aConfigFile))
	}
	zap.L().Debug("Debug is on")

	Cl100kBaseAPIService := aitokenizer.NewCl100kBaseAPIService()
	Cl100kBaseAPIController := aitokenizer.NewCl100kBaseAPIController(Cl100kBaseAPIService)

	ClaudeAPIService := aitokenizer.NewClaudeAPIService()
	ClaudeAPIController := aitokenizer.NewClaudeAPIController(ClaudeAPIService)

	DefaultAPIService := aitokenizer.NewDefaultAPIService()
	DefaultAPIController := aitokenizer.NewDefaultAPIController(DefaultAPIService)

	Gpt2APIService := aitokenizer.NewGpt2APIService()
	Gpt2APIController := aitokenizer.NewGpt2APIController(Gpt2APIService)

	O200kBaseAPIService := aitokenizer.NewO200kBaseAPIService()
	O200kBaseAPIController := aitokenizer.NewO200kBaseAPIController(O200kBaseAPIService)

	P50kBaseAPIService := aitokenizer.NewP50kBaseAPIService()
	P50kBaseAPIController := aitokenizer.NewP50kBaseAPIController(P50kBaseAPIService)

	P50kEditAPIService := aitokenizer.NewP50kEditAPIService()
	P50kEditAPIController := aitokenizer.NewP50kEditAPIController(P50kEditAPIService)

	R50kBaseAPIService := aitokenizer.NewR50kBaseAPIService()
	R50kBaseAPIController := aitokenizer.NewR50kBaseAPIController(R50kBaseAPIService)

	router := aitokenizer.NewRouter(Cl100kBaseAPIController, ClaudeAPIController, DefaultAPIController, Gpt2APIController, O200kBaseAPIController, P50kBaseAPIController, P50kEditAPIController, R50kBaseAPIController)

	// Define our server. Note this is a non-TLS server, not suitable for exposure to the wild Internet.

	addr := viper.GetString("http_server.address") + ":" + strconv.Itoa(viper.GetInt("http_server.port"))

	server := &http.Server{
		Addr:              addr,
		Handler:           router,
		MaxHeaderBytes:    viper.GetInt("http_server.max_header_bytes"),
		ReadTimeout:       time.Duration(viper.GetInt("http_server.read_timeout")) * time.Second,
		ReadHeaderTimeout: time.Duration(viper.GetInt("http_server.read_header_timeout")) * time.Second,
		WriteTimeout:      time.Duration(viper.GetInt("http_server.write_timeout")) * time.Second,
		IdleTimeout:       time.Duration(viper.GetInt("http_server.idle_timeout")) * time.Second,
	}

	// Setup graceful shutdown

	go func() {
		if err := server.ListenAndServe(); !errors.Is(err, http.ErrServerClosed) {
			zap.L().Fatal("HTTP server error: %v", zap.Error(err))
		}
		zap.L().Info("Stopped serving new connections")
	}()

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	<-sigChan

	shutdownCtx, shutdownRelease := context.WithTimeout(context.Background(), 5*time.Second)
	defer shutdownRelease()

	if err := server.Shutdown(shutdownCtx); err != nil {
		zap.L().Fatal("HTTP shutdown error: %v", zap.Error(err))
	}
	zap.L().Info("Graceful shutdown complete")

}

func showVersion() {
	fmt.Printf("ServiceName: %s\n", aitokenizer.ServiceName)
	fmt.Printf("Version:     %s\n", aitokenizer.Version)
	fmt.Printf("Revision:    %s\n", aitokenizer.Revision)
	fmt.Printf("Branch:      %s\n", aitokenizer.Branch)
	fmt.Printf("BuildDate:   %s\n", aitokenizer.BuildDate)
	fmt.Printf("OSArch:      %s\n", aitokenizer.OSArch)
	fmt.Printf("GoVersion:   %s\n", aitokenizer.GoVersion)
}
